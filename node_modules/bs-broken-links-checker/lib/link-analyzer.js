'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _routePattern = require('route-pattern');

var _routePattern2 = _interopRequireDefault(_routePattern);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _checker = require('./checker');

var _checker2 = _interopRequireDefault(_checker);

/**
 * @class LinkAnalyzer
 * @desc Hold logic about recursive links processing
 */

var LinkAnalyzer = (function () {
    /**
     * Initialize predefined skip rules for prevent deeper crawling for given url
     * @param {String} initial url
     * @param {Object} options object
     * @constructor
     */

    function LinkAnalyzer(initial, options) {
        _classCallCheck(this, LinkAnalyzer);

        /**
         * Parsed url object from Url.parse
         * @param  {Object} initial url - base (root) url where analyze started from
         * @return {Object} options object
         */
        this._url = _url2['default'].parse(initial);
        this._options = options;
    }

    /**
     * Returns options model
     * @returns {BasedOption}
     */

    _createClass(LinkAnalyzer, [{
        key: 'isNeedToSkipUrl',

        /**
         * Returns true if anyone of skip conditions returns true
         * @param {String} url url of link
         * @param {String} baseUrl url of page where link is
         * @returns {boolean} result flag
         * @public
         */
        value: function isNeedToSkipUrl(url, baseUrl) {
            var _this = this;

            return ['_skipNonAcceptableProtocols', '_skipExternalUrls', '_skipExcludedUrls', '_skipOnMode'].some(function (fName) {
                return _this[fName](url, baseUrl);
            });
        }

        /**
         * Checks if given url is external
         * @param  {String}  url request url
         * @return {boolean} true if url is external. false otherwise
         * @public
         */
    }, {
        key: 'isExternal',
        value: function isExternal(url) {
            return url.indexOf(this._url['hostname']) < 0;
        }

        /**
         * Check if protocol of given url satisfies acceptedSchemes criteria
         * @param {String} url request url
         * @returns {boolean} result flag
         * @private
         */
    }, {
        key: '_skipNonAcceptableProtocols',
        value: function _skipNonAcceptableProtocols(url) {
            return this._options.getOption('acceptedSchemes').indexOf(_url2['default'].parse(url).protocol) < 0;
        }

        /**
         * Checks if given url has the different hostname then initial
         * (If 'checkExternalUrls'rule is set to true)
         * @param {String} url request url
         * @returns {boolean} result flag
         * @private
         */
    }, {
        key: '_skipExternalUrls',
        value: function _skipExternalUrls(url) {
            return !this._options.getOption('checkExternalUrls') && url.indexOf(this._url['hostname']) < 0;
        }

        /**
         * Checks if given url has host different then host of initial url
         * @param {String} url request
         * @returns {boolean} result flag
         * @private
         */
    }, {
        key: '_skipExcludedUrls',
        value: function _skipExcludedUrls(url) {
            return this._options.getOption('excludeLinkPatterns').some(function (pattern) {
                return _lodash2['default'].isRegExp(pattern) ? pattern.test(url) : _routePattern2['default'].fromString(pattern).matches(url);
            });
        }

        /**
         * Checks if given url is need to be check depending on mode configuration option
         * @type {boolean} result flag
         * @private
         */
    }, {
        key: '_skipOnMode',
        value: function _skipOnMode(url, baseUrl) {
            var mode = this._options.getOption('mode'),
                baseUrlParsed = _url2['default'].parse(baseUrl);

            var MODES = _checker2['default'].CONSTANTS.MODE;
            if (mode === MODES.PAGE) {
                return baseUrlParsed.path !== this._url.path;
            } else if (mode === MODES.SECTION) {
                return baseUrlParsed.path.indexOf(this._url.path) === -1;
            } else {
                return false;
            }
        }
    }, {
        key: 'options',
        get: function get() {
            return this._options;
        }

        /**
         * Returns initial url as parsed url string via Url module
         * @returns {Object}
         */
    }, {
        key: 'url',
        get: function get() {
            return this._url;
        }
    }]);

    return LinkAnalyzer;
})();

exports['default'] = LinkAnalyzer;
module.exports = exports['default'];